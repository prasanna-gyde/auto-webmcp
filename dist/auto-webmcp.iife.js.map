{
  "version": 3,
  "sources": ["../src/registry.ts", "../src/index.ts", "../src/config.ts", "../src/schema.ts", "../src/analyzer.ts", "../src/discovery.ts", "../src/interceptor.ts", "../src/enhancer.ts"],
  "sourcesContent": ["/**\n * registry.ts \u2014 Wrapper around navigator.modelContext WebMCP Imperative API\n */\n\nimport { ToolMetadata } from './analyzer.js';\n\n// ---------------------------------------------------------------------------\n// WebMCP type declarations (not yet in TypeScript DOM lib)\n// ---------------------------------------------------------------------------\n\nexport interface WebMCPTool {\n  name: string;\n  description: string;\n  inputSchema: object;\n  execute: (params: Record<string, unknown>) => Promise<unknown>;\n}\n\ndeclare global {\n  interface Navigator {\n    modelContext?: {\n      registerTool(tool: WebMCPTool): Promise<void>;\n      unregisterTool(name: string): Promise<void>;\n    };\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Registry\n// ---------------------------------------------------------------------------\n\n/** Tracks registered tools: form element \u2192 tool name */\nconst registeredTools = new Map<HTMLFormElement, string>();\n\n/** True if the browser supports navigator.modelContext */\nexport function isWebMCPSupported(): boolean {\n  return typeof navigator !== 'undefined' && typeof navigator.modelContext !== 'undefined';\n}\n\n/**\n * Register a form as a WebMCP tool.\n * Silently no-ops if WebMCP is not supported.\n */\nexport async function registerFormTool(\n  form: HTMLFormElement,\n  metadata: ToolMetadata,\n  execute: (params: Record<string, unknown>) => Promise<unknown>,\n): Promise<void> {\n  if (!isWebMCPSupported()) return;\n\n  // Unregister any previously-registered tool for this same form element\n  const existing = registeredTools.get(form);\n  if (existing) {\n    await unregisterFormTool(form);\n  }\n\n  await navigator.modelContext!.registerTool({\n    name: metadata.name,\n    description: metadata.description,\n    inputSchema: metadata.inputSchema,\n    execute,\n  });\n\n  registeredTools.set(form, metadata.name);\n}\n\n/**\n * Unregister the WebMCP tool associated with a form element.\n * Silently no-ops if not registered or WebMCP not supported.\n */\nexport async function unregisterFormTool(form: HTMLFormElement): Promise<void> {\n  if (!isWebMCPSupported()) return;\n\n  const name = registeredTools.get(form);\n  if (!name) return;\n\n  try {\n    await navigator.modelContext!.unregisterTool(name);\n  } catch {\n    // Tool may have already been removed \u2014 ignore\n  }\n\n  registeredTools.delete(form);\n}\n\n/** Get the registered tool name for a form, if any */\nexport function getRegisteredToolName(form: HTMLFormElement): string | undefined {\n  return registeredTools.get(form);\n}\n\n/** Return a snapshot of all currently registered form\u2192name pairs */\nexport function getAllRegisteredTools(): Array<{ form: HTMLFormElement; name: string }> {\n  return Array.from(registeredTools.entries()).map(([form, name]) => ({ form, name }));\n}\n\n/** Unregister all tools (e.g. on teardown) */\nexport async function unregisterAll(): Promise<void> {\n  const entries = Array.from(registeredTools.entries());\n  await Promise.all(entries.map(([form]) => unregisterFormTool(form)));\n}\n", "/**\n * index.ts \u2014 Entry point & public API for auto-webmcp\n *\n * Zero-config drop-in:\n *   <script src=\"auto-webmcp.iife.js\"></script>\n *\n * ESM usage:\n *   import { autoWebMCP } from 'auto-webmcp';\n *   autoWebMCP({ exclude: ['#login-form'] });\n */\n\nimport { AutoWebMCPConfig, resolveConfig } from './config.js';\nimport { startDiscovery, stopDiscovery } from './discovery.js';\nimport { unregisterAll, getAllRegisteredTools, isWebMCPSupported } from './registry.js';\n\nexport type { AutoWebMCPConfig } from './config.js';\nexport type { ToolMetadata } from './analyzer.js';\nexport type { JsonSchema, JsonSchemaProperty } from './schema.js';\n\nexport interface AutoWebMCPHandle {\n  /** Stop observing and unregister all tools */\n  destroy: () => Promise<void>;\n  /** Return all currently registered tools */\n  getTools: () => Array<{ form: HTMLFormElement; name: string }>;\n  /** True if running in a WebMCP-capable browser */\n  isSupported: boolean;\n}\n\n/**\n * Initialize auto-webmcp.\n *\n * @param config \u2014 Optional configuration (all fields optional)\n * @returns A handle to inspect or tear down the instance\n */\nexport async function autoWebMCP(config?: AutoWebMCPConfig): Promise<AutoWebMCPHandle> {\n  const resolved = resolveConfig(config);\n\n  if (resolved.debug) {\n    console.debug('[auto-webmcp] Initializing', {\n      webmcpSupported: isWebMCPSupported(),\n      config: resolved,\n    });\n  }\n\n  await startDiscovery(resolved);\n\n  return {\n    destroy: async () => {\n      stopDiscovery();\n      await unregisterAll();\n    },\n    getTools: getAllRegisteredTools,\n    isSupported: isWebMCPSupported(),\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Auto-init for IIFE / script-tag usage\n// ---------------------------------------------------------------------------\n\n// When loaded as a <script> tag, auto-initialize with zero config.\n// Users can prevent this by setting window.__AUTO_WEBMCP_NO_AUTOINIT = true\n// before the script loads.\n\nif (\n  typeof window !== 'undefined' &&\n  !(window as unknown as Record<string, unknown>)['__AUTO_WEBMCP_NO_AUTOINIT']\n) {\n  void autoWebMCP();\n}\n", "/**\n * config.ts \u2014 User configuration merging & defaults\n */\n\nexport interface EnhancerConfig {\n  provider: 'gemini' | 'claude';\n  apiKey: string;\n  model?: string;\n}\n\nexport interface FormOverride {\n  name?: string;\n  description?: string;\n}\n\nexport interface AutoWebMCPConfig {\n  /**\n   * CSS selectors for forms to skip. E.g. ['#login-form', '[data-no-webmcp]']\n   */\n  exclude?: string[];\n\n  /**\n   * If true, agent-invoked forms are auto-submitted without human confirmation.\n   * Default: false\n   */\n  autoSubmit?: boolean;\n\n  /**\n   * Optional AI enrichment for richer tool descriptions.\n   */\n  enhance?: EnhancerConfig;\n\n  /**\n   * Per-form name/description overrides keyed by CSS selector.\n   */\n  overrides?: Record<string, FormOverride>;\n\n  /**\n   * Log registered tools to console on init. Default: false\n   */\n  debug?: boolean;\n}\n\nexport interface ResolvedConfig {\n  exclude: string[];\n  autoSubmit: boolean;\n  enhance: EnhancerConfig | null;\n  overrides: Record<string, FormOverride>;\n  debug: boolean;\n}\n\nexport function resolveConfig(userConfig?: AutoWebMCPConfig): ResolvedConfig {\n  return {\n    exclude: userConfig?.exclude ?? [],\n    autoSubmit: userConfig?.autoSubmit ?? false,\n    enhance: userConfig?.enhance ?? null,\n    overrides: userConfig?.overrides ?? {},\n    debug: userConfig?.debug ?? false,\n  };\n}\n", "/**\n * schema.ts \u2014 HTML input type \u2192 JSON Schema type mapping\n */\n\nexport interface JsonSchemaProperty {\n  type: string;\n  format?: string;\n  description?: string;\n  title?: string;\n  enum?: string[];\n  minimum?: number;\n  maximum?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: string;\n}\n\nexport interface JsonSchema {\n  type: 'object';\n  properties: Record<string, JsonSchemaProperty>;\n  required: string[];\n}\n\n/** Maps an HTML <input type> to a JSON Schema property base */\nexport function inputTypeToSchema(\n  input: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement,\n): JsonSchemaProperty | null {\n  if (input instanceof HTMLInputElement) {\n    return mapInputElement(input);\n  }\n  if (input instanceof HTMLTextAreaElement) {\n    return { type: 'string' };\n  }\n  if (input instanceof HTMLSelectElement) {\n    return mapSelectElement(input);\n  }\n  return null;\n}\n\nfunction mapInputElement(input: HTMLInputElement): JsonSchemaProperty | null {\n  const type = input.type.toLowerCase();\n\n  switch (type) {\n    case 'text':\n    case 'search':\n    case 'tel':\n      return buildStringSchema(input);\n\n    case 'email':\n      return { ...buildStringSchema(input), format: 'email' };\n\n    case 'url':\n      return { ...buildStringSchema(input), format: 'uri' };\n\n    case 'number':\n    case 'range': {\n      const prop: JsonSchemaProperty = { type: 'number' };\n      if (input.min !== '') prop.minimum = parseFloat(input.min);\n      if (input.max !== '') prop.maximum = parseFloat(input.max);\n      return prop;\n    }\n\n    case 'date':\n      return { type: 'string', format: 'date' };\n\n    case 'datetime-local':\n      return { type: 'string', format: 'date-time' };\n\n    case 'time':\n      return { type: 'string', format: 'time' };\n\n    case 'month':\n      return { type: 'string', pattern: '^\\\\d{4}-\\\\d{2}$' };\n\n    case 'week':\n      return { type: 'string', pattern: '^\\\\d{4}-W\\\\d{2}$' };\n\n    case 'color':\n      return { type: 'string', pattern: '^#[0-9a-fA-F]{6}$' };\n\n    case 'checkbox':\n      return { type: 'boolean' };\n\n    case 'radio':\n      // Radio groups are handled at the form level in analyzer.ts\n      return { type: 'string' };\n\n    case 'file':\n    case 'hidden':\n    case 'submit':\n    case 'reset':\n    case 'button':\n    case 'image':\n      // These are not exposed to agents\n      return null;\n\n    case 'password':\n      // Skip passwords \u2014 never expose to agents\n      return null;\n\n    default:\n      return { type: 'string' };\n  }\n}\n\nfunction buildStringSchema(input: HTMLInputElement): JsonSchemaProperty {\n  const prop: JsonSchemaProperty = { type: 'string' };\n  if (input.minLength > 0) prop.minLength = input.minLength;\n  if (input.maxLength > 0 && input.maxLength !== 524288) prop.maxLength = input.maxLength;\n  if (input.pattern) prop.pattern = input.pattern;\n  return prop;\n}\n\nfunction mapSelectElement(select: HTMLSelectElement): JsonSchemaProperty {\n  const options = Array.from(select.options)\n    .filter((o) => o.value !== '')\n    .map((o) => o.value);\n\n  if (options.length === 0) {\n    return { type: 'string' };\n  }\n\n  return {\n    type: 'string',\n    enum: options,\n  };\n}\n\n/** Collect all radio button values for a given name within a form */\nexport function collectRadioEnum(form: HTMLFormElement, name: string): string[] {\n  const radios = Array.from(\n    form.querySelectorAll<HTMLInputElement>(`input[type=\"radio\"][name=\"${CSS.escape(name)}\"]`),\n  );\n  return radios.map((r) => r.value).filter((v) => v !== '');\n}\n", "/**\n * analyzer.ts \u2014 Infer tool name, description, and JSON Schema from form DOM\n */\n\nimport { JsonSchema, JsonSchemaProperty, inputTypeToSchema, collectRadioEnum } from './schema.js';\nimport { FormOverride } from './config.js';\n\nexport interface ToolMetadata {\n  name: string;\n  description: string;\n  inputSchema: JsonSchema;\n}\n\n// Track form index for fallback naming\nlet formIndex = 0;\n\n/** Reset form index counter (useful in tests) */\nexport function resetFormIndex(): void {\n  formIndex = 0;\n}\n\n/** Derive ToolMetadata from a <form> element */\nexport function analyzeForm(form: HTMLFormElement, override?: FormOverride): ToolMetadata {\n  const name = override?.name ?? inferToolName(form);\n  const description = override?.description ?? inferToolDescription(form);\n  const inputSchema = buildSchema(form);\n\n  return { name, description, inputSchema };\n}\n\n// ---------------------------------------------------------------------------\n// Tool name inference\n// ---------------------------------------------------------------------------\n\nfunction inferToolName(form: HTMLFormElement): string {\n  // 1. Explicit data attribute\n  const explicit = form.dataset['webmcpName'];\n  if (explicit) return sanitizeName(explicit);\n\n  // 2. Submit button text\n  const submitText = getSubmitButtonText(form);\n  if (submitText) return sanitizeName(submitText);\n\n  // 3. Nearest heading above the form\n  const heading = getNearestHeadingText(form);\n  if (heading) return sanitizeName(heading);\n\n  // 4. Form id or name attribute\n  if (form.id) return sanitizeName(form.id);\n  if (form.name) return sanitizeName(form.name);\n\n  // 5. Form action URL path segment\n  if (form.action) {\n    const segment = getLastPathSegment(form.action);\n    if (segment) return sanitizeName(segment);\n  }\n\n  // 6. Fallback\n  return `form_${++formIndex}`;\n}\n\nfunction sanitizeName(raw: string): string {\n  return raw\n    .toLowerCase()\n    .trim()\n    .replace(/[^a-z0-9]+/g, '_')\n    .replace(/^_+|_+$/g, '')\n    .slice(0, 64) || 'form';\n}\n\nfunction getSubmitButtonText(form: HTMLFormElement): string {\n  const buttons = [\n    ...Array.from(form.querySelectorAll<HTMLButtonElement>('button[type=\"submit\"], button:not([type])')),\n    ...Array.from(form.querySelectorAll<HTMLInputElement>('input[type=\"submit\"]')),\n  ];\n\n  for (const btn of buttons) {\n    const text =\n      btn instanceof HTMLInputElement\n        ? btn.value.trim()\n        : btn.textContent?.trim() ?? '';\n    if (text && text.length > 0 && text.length < 80) return text;\n  }\n  return '';\n}\n\nfunction getNearestHeadingText(form: HTMLFormElement): string {\n  // Walk up the DOM looking for a preceding sibling or parent heading\n  let node: Element | null = form;\n  while (node) {\n    // Check preceding siblings\n    let sibling = node.previousElementSibling;\n    while (sibling) {\n      if (/^H[1-3]$/i.test(sibling.tagName)) {\n        const text = sibling.textContent?.trim() ?? '';\n        if (text) return text;\n      }\n      sibling = sibling.previousElementSibling;\n    }\n    node = node.parentElement;\n    // Stop at body\n    if (!node || node === document.body) break;\n  }\n  return '';\n}\n\nfunction getLastPathSegment(url: string): string {\n  try {\n    const parsed = new URL(url, window.location.href);\n    const segments = parsed.pathname.split('/').filter(Boolean);\n    return segments[segments.length - 1] ?? '';\n  } catch {\n    return '';\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Tool description inference\n// ---------------------------------------------------------------------------\n\nfunction inferToolDescription(form: HTMLFormElement): string {\n  // 1. Explicit data attribute\n  const explicit = form.dataset['webmcpDescription'];\n  if (explicit) return explicit.trim();\n\n  // 2. <legend> inside the form\n  const legend = form.querySelector('legend');\n  if (legend?.textContent?.trim()) return legend.textContent.trim();\n\n  // 3. aria-label on the form\n  const ariaLabel = form.getAttribute('aria-label');\n  if (ariaLabel?.trim()) return ariaLabel.trim();\n\n  // 4. aria-describedby\n  const describedById = form.getAttribute('aria-describedby');\n  if (describedById) {\n    const descEl = document.getElementById(describedById);\n    if (descEl?.textContent?.trim()) return descEl.textContent.trim();\n  }\n\n  // 5. Combine nearest heading + page title\n  const heading = getNearestHeadingText(form);\n  const pageTitle = document.title?.trim();\n  if (heading && pageTitle) return `${heading} \u2014 ${pageTitle}`;\n  if (heading) return heading;\n  if (pageTitle) return pageTitle;\n\n  return 'Submit form';\n}\n\n// ---------------------------------------------------------------------------\n// JSON Schema construction\n// ---------------------------------------------------------------------------\n\nfunction buildSchema(form: HTMLFormElement): JsonSchema {\n  const properties: Record<string, JsonSchemaProperty> = {};\n  const required: string[] = [];\n\n  // Track which radio group names we've already processed\n  const processedRadioGroups = new Set<string>();\n\n  const controls = Array.from(\n    form.querySelectorAll<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>(\n      'input, textarea, select',\n    ),\n  );\n\n  for (const control of controls) {\n    // Skip unnamed controls \u2014 can't be submitted\n    const name = control.name;\n    if (!name) continue;\n\n    // Skip already-processed radio groups\n    if (\n      control instanceof HTMLInputElement &&\n      control.type === 'radio'\n    ) {\n      if (processedRadioGroups.has(name)) continue;\n      processedRadioGroups.add(name);\n    }\n\n    const schemaProp = inputTypeToSchema(control);\n    if (!schemaProp) continue; // skipped types\n\n    // Enrich with title and description\n    schemaProp.title = inferFieldTitle(control);\n    const desc = inferFieldDescription(control);\n    if (desc) schemaProp.description = desc;\n\n    // For radio groups, add enum values\n    if (\n      control instanceof HTMLInputElement &&\n      control.type === 'radio'\n    ) {\n      schemaProp.enum = collectRadioEnum(form, name);\n    }\n\n    properties[name] = schemaProp;\n\n    // Mark as required if the HTML attribute says so\n    if (control.required) {\n      required.push(name);\n    }\n  }\n\n  return { type: 'object', properties, required };\n}\n\nfunction inferFieldTitle(\n  control: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement,\n): string {\n  // 1. data-webmcp-title\n  if ('dataset' in control && (control as HTMLElement).dataset['webmcpTitle']) {\n    return (control as HTMLElement).dataset['webmcpTitle']!;\n  }\n\n  // 2. Associated <label> text\n  const labelText = getAssociatedLabelText(control);\n  if (labelText) return labelText;\n\n  // 3. name attribute (humanised)\n  if (control.name) return humanizeName(control.name);\n\n  // 4. id attribute (humanised)\n  if (control.id) return humanizeName(control.id);\n\n  return '';\n}\n\nfunction inferFieldDescription(\n  control: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement,\n): string {\n  // 1. data-webmcp-description\n  const el = control as HTMLElement;\n  if (el.dataset['webmcpDescription']) return el.dataset['webmcpDescription']!;\n\n  // 2. aria-description or aria-describedby\n  const ariaDesc = control.getAttribute('aria-description');\n  if (ariaDesc) return ariaDesc;\n\n  const describedById = control.getAttribute('aria-describedby');\n  if (describedById) {\n    const descEl = document.getElementById(describedById);\n    if (descEl?.textContent?.trim()) return descEl.textContent.trim();\n  }\n\n  // 3. placeholder (only as a last resort \u2014 can be noisy)\n  if (control instanceof HTMLInputElement || control instanceof HTMLTextAreaElement) {\n    const ph = control.placeholder?.trim();\n    if (ph && ph.length > 0) return ph;\n  }\n\n  // 4. Associated label text (if title didn't use it, use it for description)\n  return '';\n}\n\nfunction getAssociatedLabelText(\n  control: HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement,\n): string {\n  // 1. Labels collection (for/id association)\n  if (control.id) {\n    const label = document.querySelector<HTMLLabelElement>(`label[for=\"${CSS.escape(control.id)}\"]`);\n    if (label) {\n      const text = labelTextWithoutNested(label);\n      if (text) return text;\n    }\n  }\n\n  // 2. Wrapping <label>\n  const parent = control.closest('label');\n  if (parent) {\n    const text = labelTextWithoutNested(parent);\n    if (text) return text;\n  }\n\n  return '';\n}\n\nfunction labelTextWithoutNested(label: HTMLLabelElement): string {\n  // Clone and remove any nested input/select/textarea before getting text\n  const clone = label.cloneNode(true) as HTMLLabelElement;\n  clone.querySelectorAll('input, select, textarea, button').forEach((el) => el.remove());\n  return clone.textContent?.trim() ?? '';\n}\n\nfunction humanizeName(raw: string): string {\n  return raw\n    .replace(/[-_]/g, ' ')\n    .replace(/([a-z])([A-Z])/g, '$1 $2')\n    .trim()\n    .replace(/\\b\\w/g, (c) => c.toUpperCase());\n}\n", "/**\n * discovery.ts \u2014 Form scanning & MutationObserver for SPA support\n */\n\nimport { ResolvedConfig } from './config.js';\nimport { analyzeForm } from './analyzer.js';\nimport { registerFormTool, unregisterFormTool } from './registry.js';\nimport { buildExecuteHandler } from './interceptor.js';\nimport { enrichMetadata } from './enhancer.js';\n\n// ---------------------------------------------------------------------------\n// Events\n// ---------------------------------------------------------------------------\n\nexport type FormLifecycleEvent = CustomEvent<{\n  form: HTMLFormElement;\n  toolName: string;\n}>;\n\nfunction emit(type: 'form:registered' | 'form:unregistered', form: HTMLFormElement, toolName: string): void {\n  window.dispatchEvent(\n    new CustomEvent(type, { detail: { form, toolName } }) as FormLifecycleEvent,\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Registration helpers\n// ---------------------------------------------------------------------------\n\n/** Check whether a form should be excluded per config */\nfunction isExcluded(form: HTMLFormElement, config: ResolvedConfig): boolean {\n  // Skip forms that already have explicit WebMCP attributes (browser handles)\n  if (form.hasAttribute('toolname')) return true;\n  // Skip forms with data-no-webmcp\n  if (form.dataset['noWebmcp'] !== undefined) return true;\n  // Skip per config exclude list\n  for (const selector of config.exclude) {\n    try {\n      if (form.matches(selector)) return true;\n    } catch {\n      // invalid selector \u2014 ignore\n    }\n  }\n  return false;\n}\n\nasync function registerForm(form: HTMLFormElement, config: ResolvedConfig): Promise<void> {\n  if (isExcluded(form, config)) return;\n\n  // Find matching override (first matching selector wins)\n  let override;\n  for (const [selector, ovr] of Object.entries(config.overrides)) {\n    try {\n      if (form.matches(selector)) {\n        override = ovr;\n        break;\n      }\n    } catch {\n      // invalid selector\n    }\n  }\n\n  let metadata = analyzeForm(form, override);\n  if (config.enhance) {\n    if (config.debug) console.debug(`[auto-webmcp] Enriching: ${metadata.name}\u2026`);\n    metadata = await enrichMetadata(metadata, config.enhance);\n  }\n  const execute = buildExecuteHandler(form, config);\n\n  await registerFormTool(form, metadata, execute);\n\n  if (config.debug) {\n    console.debug(`[auto-webmcp] Registered: ${metadata.name}`, metadata);\n  }\n\n  emit('form:registered', form, metadata.name);\n}\n\nasync function unregisterForm(form: HTMLFormElement, config: ResolvedConfig): Promise<void> {\n  const { getRegisteredToolName } = await import('./registry.js');\n  const name = getRegisteredToolName(form);\n  if (!name) return;\n\n  await unregisterFormTool(form);\n\n  if (config.debug) {\n    console.debug(`[auto-webmcp] Unregistered: ${name}`);\n  }\n\n  emit('form:unregistered', form, name);\n}\n\n// ---------------------------------------------------------------------------\n// MutationObserver\n// ---------------------------------------------------------------------------\n\nlet observer: MutationObserver | null = null;\n\nfunction startObserver(config: ResolvedConfig): void {\n  if (observer) return;\n\n  observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n      for (const node of mutation.addedNodes) {\n        if (!(node instanceof Element)) continue;\n\n        const forms = node instanceof HTMLFormElement\n          ? [node]\n          : Array.from(node.querySelectorAll<HTMLFormElement>('form'));\n\n        for (const form of forms) {\n          void registerForm(form, config);\n        }\n      }\n\n      for (const node of mutation.removedNodes) {\n        if (!(node instanceof Element)) continue;\n\n        const forms = node instanceof HTMLFormElement\n          ? [node]\n          : Array.from(node.querySelectorAll<HTMLFormElement>('form'));\n\n        for (const form of forms) {\n          void unregisterForm(form, config);\n        }\n      }\n    }\n  });\n\n  observer.observe(document.body, { childList: true, subtree: true });\n}\n\n// ---------------------------------------------------------------------------\n// SPA route change support\n// ---------------------------------------------------------------------------\n\nfunction listenForRouteChanges(config: ResolvedConfig): void {\n  // Hash changes\n  window.addEventListener('hashchange', () => scanForms(config));\n\n  // History API (pushState / replaceState)\n  const original = {\n    pushState: history.pushState.bind(history),\n    replaceState: history.replaceState.bind(history),\n  };\n\n  history.pushState = function (...args) {\n    original.pushState(...args);\n    scanForms(config);\n  };\n\n  history.replaceState = function (...args) {\n    original.replaceState(...args);\n    scanForms(config);\n  };\n\n  window.addEventListener('popstate', () => scanForms(config));\n}\n\n// ---------------------------------------------------------------------------\n// Main scan\n// ---------------------------------------------------------------------------\n\nasync function scanForms(config: ResolvedConfig): Promise<void> {\n  const forms = Array.from(document.querySelectorAll<HTMLFormElement>('form'));\n  await Promise.all(forms.map((form) => registerForm(form, config)));\n}\n\n// ---------------------------------------------------------------------------\n// Public API\n// ---------------------------------------------------------------------------\n\nexport async function startDiscovery(config: ResolvedConfig): Promise<void> {\n  if (document.readyState === 'loading') {\n    await new Promise<void>((resolve) =>\n      document.addEventListener('DOMContentLoaded', () => resolve(), { once: true }),\n    );\n  }\n\n  await scanForms(config);\n  startObserver(config);\n  listenForRouteChanges(config);\n}\n\nexport function stopDiscovery(): void {\n  observer?.disconnect();\n  observer = null;\n}\n", "/**\n * interceptor.ts \u2014 Form submit interception for agent-invoked submissions\n *\n * WebMCP's `execute` callback receives form parameters and is expected to\n * return a result. This module bridges the gap: it fills form fields with\n * the agent-supplied values, submits the form, and resolves the execute\n * promise with a structured response.\n */\n\nimport { ResolvedConfig } from './config.js';\n\n// ---------------------------------------------------------------------------\n// Extended SubmitEvent types (WebMCP additions)\n// ---------------------------------------------------------------------------\n\ndeclare global {\n  interface SubmitEvent {\n    /** True when the form was submitted by an AI agent via WebMCP */\n    agentInvoked?: boolean;\n    /** Call to return a structured result to the agent */\n    respondWith?: (promise: Promise<unknown>) => void;\n  }\n}\n\nexport interface ExecuteResult {\n  success: boolean;\n  data?: Record<string, unknown>;\n  url?: string;\n  error?: string;\n}\n\ntype Resolver = (result: ExecuteResult) => void;\ntype Rejecter = (error: Error) => void;\n\n/** Per-form pending execute promises */\nconst pendingExecutions = new WeakMap<\n  HTMLFormElement,\n  { resolve: Resolver; reject: Rejecter }\n>();\n\n/**\n * Build an `execute` function for a form tool.\n *\n * When the agent calls execute(params):\n *  1. Fills form fields with the supplied params\n *  2. Fires a submit event (or auto-submits if configured)\n *  3. Resolves with structured form data once submitted\n */\nexport function buildExecuteHandler(\n  form: HTMLFormElement,\n  config: ResolvedConfig,\n): (params: Record<string, unknown>) => Promise<ExecuteResult> {\n  // Attach submit listener once per form\n  attachSubmitInterceptor(form);\n\n  return async (params: Record<string, unknown>): Promise<ExecuteResult> => {\n    fillFormFields(form, params);\n\n    return new Promise<ExecuteResult>((resolve, reject) => {\n      pendingExecutions.set(form, { resolve, reject });\n\n      if (config.autoSubmit || form.dataset['webmcpAutosubmit'] !== undefined) {\n        // Programmatically submit\n        form.requestSubmit();\n      }\n      // Otherwise: the form stays filled; human clicks submit,\n      // which fires the submit event interceptor below.\n    });\n  };\n}\n\nfunction attachSubmitInterceptor(form: HTMLFormElement): void {\n  // Guard against attaching multiple times\n  if ((form as unknown as Record<string, unknown>)['__awmcp_intercepted']) return;\n  (form as unknown as Record<string, unknown>)['__awmcp_intercepted'] = true;\n\n  form.addEventListener('submit', (e: SubmitEvent) => {\n    const pending = pendingExecutions.get(form);\n    if (!pending) return; // Normal human submission \u2014 do nothing\n\n    // Agent-invoked path\n    const { resolve } = pending;\n    pendingExecutions.delete(form);\n\n    const formData = serializeFormData(form);\n\n    if (e.agentInvoked && typeof e.respondWith === 'function') {\n      // Native WebMCP path: use respondWith to return to browser\n      e.preventDefault();\n      e.respondWith(\n        Promise.resolve({\n          success: true,\n          data: formData,\n        }),\n      );\n      resolve({ success: true, data: formData });\n    } else {\n      // Fallback path: let form submit normally, resolve with data + target URL\n      const targetUrl = resolveFormAction(form);\n      resolve({ success: true, data: formData, url: targetUrl });\n    }\n  });\n}\n\n// ---------------------------------------------------------------------------\n// Field filling\n// ---------------------------------------------------------------------------\n\nfunction fillFormFields(form: HTMLFormElement, params: Record<string, unknown>): void {\n  for (const [name, value] of Object.entries(params)) {\n    const escapedName = CSS.escape(name);\n\n    // Try input, textarea, select with this name\n    const input = form.querySelector<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>(\n      `[name=\"${escapedName}\"]`,\n    );\n\n    if (!input) continue;\n\n    if (input instanceof HTMLInputElement) {\n      fillInput(input, form, name, value);\n    } else if (input instanceof HTMLTextAreaElement) {\n      input.value = String(value ?? '');\n      input.dispatchEvent(new Event('input', { bubbles: true }));\n      input.dispatchEvent(new Event('change', { bubbles: true }));\n    } else if (input instanceof HTMLSelectElement) {\n      input.value = String(value ?? '');\n      input.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n  }\n}\n\nfunction fillInput(\n  input: HTMLInputElement,\n  form: HTMLFormElement,\n  name: string,\n  value: unknown,\n): void {\n  const type = input.type.toLowerCase();\n\n  if (type === 'checkbox') {\n    input.checked = Boolean(value);\n    input.dispatchEvent(new Event('change', { bubbles: true }));\n    return;\n  }\n\n  if (type === 'radio') {\n    const escapedName = CSS.escape(name);\n    const radios = form.querySelectorAll<HTMLInputElement>(\n      `input[type=\"radio\"][name=\"${escapedName}\"]`,\n    );\n    for (const radio of radios) {\n      if (radio.value === String(value)) {\n        radio.checked = true;\n        radio.dispatchEvent(new Event('change', { bubbles: true }));\n        break;\n      }\n    }\n    return;\n  }\n\n  input.value = String(value ?? '');\n  input.dispatchEvent(new Event('input', { bubbles: true }));\n  input.dispatchEvent(new Event('change', { bubbles: true }));\n}\n\n// ---------------------------------------------------------------------------\n// Serialization\n// ---------------------------------------------------------------------------\n\nfunction serializeFormData(form: HTMLFormElement): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n  const data = new FormData(form);\n\n  for (const [key, val] of data.entries()) {\n    if (result[key] !== undefined) {\n      // Multiple values \u2192 array\n      const existing = result[key];\n      if (Array.isArray(existing)) {\n        existing.push(val);\n      } else {\n        result[key] = [existing, val];\n      }\n    } else {\n      result[key] = val;\n    }\n  }\n\n  return result;\n}\n\nfunction resolveFormAction(form: HTMLFormElement): string {\n  if (form.action) {\n    try {\n      return new URL(form.action, window.location.href).href;\n    } catch {\n      // ignore\n    }\n  }\n  return window.location.href;\n}\n", "/**\n * enhancer.ts \u2014 Optional LLM-based description enrichment\n *\n * Calls a small LLM to generate richer tool descriptions than heuristics\n * alone can provide. Activated only when config.enhance is set.\n */\n\nimport { ToolMetadata } from './analyzer.js';\nimport { EnhancerConfig } from './config.js';\n\nexport async function enrichMetadata(\n  metadata: ToolMetadata,\n  enhancer: EnhancerConfig,\n): Promise<ToolMetadata> {\n  try {\n    const enriched = await callLLM(metadata, enhancer);\n    return { ...metadata, description: enriched };\n  } catch (err) {\n    // Enhancement is optional \u2014 fall back to heuristic description\n    console.warn('[auto-webmcp] Enrichment failed, using heuristic description:', err);\n    return metadata;\n  }\n}\n\nasync function callLLM(metadata: ToolMetadata, config: EnhancerConfig): Promise<string> {\n  const prompt = buildPrompt(metadata);\n\n  if (config.provider === 'claude') {\n    return callClaude(prompt, config);\n  } else {\n    return callGemini(prompt, config);\n  }\n}\n\nfunction buildPrompt(metadata: ToolMetadata): string {\n  const fields = Object.entries(metadata.inputSchema.properties)\n    .map(([name, prop]) => `- ${prop.title ?? name} (${prop.type}): ${prop.description ?? ''}`)\n    .join('\\n');\n\n  return `You are helping describe a web form as an AI tool. Given this form information:\n\nName: ${metadata.name}\nCurrent description: ${metadata.description}\nFields:\n${fields}\n\nWrite a concise (1-2 sentence) description of what this tool does and when an AI agent should use it. Be specific and actionable. Respond with only the description, no preamble.`;\n}\n\nasync function callClaude(prompt: string, config: EnhancerConfig): Promise<string> {\n  const model = config.model ?? 'claude-haiku-4-5-20251001';\n\n  const response = await fetch('https://api.anthropic.com/v1/messages', {\n    method: 'POST',\n    headers: {\n      'x-api-key': config.apiKey,\n      'anthropic-version': '2023-06-01',\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify({\n      model,\n      max_tokens: 150,\n      messages: [{ role: 'user', content: prompt }],\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Claude API error: ${response.status}`);\n  }\n\n  const data = await response.json() as {\n    content: Array<{ type: string; text: string }>;\n  };\n\n  return data.content\n    .filter((block) => block.type === 'text')\n    .map((block) => block.text)\n    .join('')\n    .trim();\n}\n\nasync function callGemini(prompt: string, config: EnhancerConfig): Promise<string> {\n  const model = config.model ?? 'gemini-1.5-flash';\n  const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${config.apiKey}`;\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: { 'content-type': 'application/json' },\n    body: JSON.stringify({\n      contents: [{ parts: [{ text: prompt }] }],\n      generationConfig: { maxOutputTokens: 150, temperature: 0.2 },\n    }),\n  });\n\n  if (!response.ok) {\n    throw new Error(`Gemini API error: ${response.status}`);\n  }\n\n  const data = await response.json() as {\n    candidates: Array<{\n      content: { parts: Array<{ text: string }> };\n    }>;\n  };\n\n  return data.candidates[0]?.content.parts.map((p) => p.text).join('').trim() ?? '';\n}\n"],
  "mappings": "ieAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,2BAAAE,EAAA,0BAAAC,GAAA,sBAAAC,EAAA,qBAAAC,EAAA,kBAAAC,EAAA,uBAAAC,IAkCO,SAASH,GAA6B,CAC3C,OAAO,OAAO,UAAc,KAAe,OAAO,UAAU,aAAiB,GAC/E,CAMA,eAAsBC,EACpBG,EACAC,EACAC,EACe,CACf,GAAI,CAACN,EAAkB,EAAG,OAGTO,EAAgB,IAAIH,CAAI,GAEvC,MAAMD,EAAmBC,CAAI,EAG/B,MAAM,UAAU,aAAc,aAAa,CACzC,KAAMC,EAAS,KACf,YAAaA,EAAS,YACtB,YAAaA,EAAS,YACtB,QAAAC,CACF,CAAC,EAEDC,EAAgB,IAAIH,EAAMC,EAAS,IAAI,CACzC,CAMA,eAAsBF,EAAmBC,EAAsC,CAC7E,GAAI,CAACJ,EAAkB,EAAG,OAE1B,IAAMQ,EAAOD,EAAgB,IAAIH,CAAI,EACrC,GAAKI,EAEL,IAAI,CACF,MAAM,UAAU,aAAc,eAAeA,CAAI,CACnD,MAAQ,CAER,CAEAD,EAAgB,OAAOH,CAAI,EAC7B,CAGO,SAASL,GAAsBK,EAA2C,CAC/E,OAAOG,EAAgB,IAAIH,CAAI,CACjC,CAGO,SAASN,GAAwE,CACtF,OAAO,MAAM,KAAKS,EAAgB,QAAQ,CAAC,EAAE,IAAI,CAAC,CAACH,EAAMI,CAAI,KAAO,CAAE,KAAAJ,EAAM,KAAAI,CAAK,EAAE,CACrF,CAGA,eAAsBN,GAA+B,CACnD,IAAMO,EAAU,MAAM,KAAKF,EAAgB,QAAQ,CAAC,EACpD,MAAM,QAAQ,IAAIE,EAAQ,IAAI,CAAC,CAACL,CAAI,IAAMD,EAAmBC,CAAI,CAAC,CAAC,CACrE,CAlGA,IA+BMG,EA/BNG,EAAAC,EAAA,kBA+BMJ,EAAkB,IAAI,MC/B5B,IAAAK,GAAA,GAAAC,EAAAD,GAAA,gBAAAE,ICmDO,SAASC,EAAcC,EAA+C,CAC3E,MAAO,CACL,QAASA,GAAY,SAAW,CAAC,EACjC,WAAYA,GAAY,YAAc,GACtC,QAASA,GAAY,SAAW,KAChC,UAAWA,GAAY,WAAa,CAAC,EACrC,MAAOA,GAAY,OAAS,EAC9B,CACF,CCnCO,SAASC,EACdC,EAC2B,CAC3B,OAAIA,aAAiB,iBACZC,EAAgBD,CAAK,EAE1BA,aAAiB,oBACZ,CAAE,KAAM,QAAS,EAEtBA,aAAiB,kBACZE,EAAiBF,CAAK,EAExB,IACT,CAEA,SAASC,EAAgBD,EAAoD,CAG3E,OAFaA,EAAM,KAAK,YAAY,EAEtB,CACZ,IAAK,OACL,IAAK,SACL,IAAK,MACH,OAAOG,EAAkBH,CAAK,EAEhC,IAAK,QACH,MAAO,CAAE,GAAGG,EAAkBH,CAAK,EAAG,OAAQ,OAAQ,EAExD,IAAK,MACH,MAAO,CAAE,GAAGG,EAAkBH,CAAK,EAAG,OAAQ,KAAM,EAEtD,IAAK,SACL,IAAK,QAAS,CACZ,IAAMI,EAA2B,CAAE,KAAM,QAAS,EAClD,OAAIJ,EAAM,MAAQ,KAAII,EAAK,QAAU,WAAWJ,EAAM,GAAG,GACrDA,EAAM,MAAQ,KAAII,EAAK,QAAU,WAAWJ,EAAM,GAAG,GAClDI,CACT,CAEA,IAAK,OACH,MAAO,CAAE,KAAM,SAAU,OAAQ,MAAO,EAE1C,IAAK,iBACH,MAAO,CAAE,KAAM,SAAU,OAAQ,WAAY,EAE/C,IAAK,OACH,MAAO,CAAE,KAAM,SAAU,OAAQ,MAAO,EAE1C,IAAK,QACH,MAAO,CAAE,KAAM,SAAU,QAAS,iBAAkB,EAEtD,IAAK,OACH,MAAO,CAAE,KAAM,SAAU,QAAS,kBAAmB,EAEvD,IAAK,QACH,MAAO,CAAE,KAAM,SAAU,QAAS,mBAAoB,EAExD,IAAK,WACH,MAAO,CAAE,KAAM,SAAU,EAE3B,IAAK,QAEH,MAAO,CAAE,KAAM,QAAS,EAE1B,IAAK,OACL,IAAK,SACL,IAAK,SACL,IAAK,QACL,IAAK,SACL,IAAK,QAEH,OAAO,KAET,IAAK,WAEH,OAAO,KAET,QACE,MAAO,CAAE,KAAM,QAAS,CAC5B,CACF,CAEA,SAASD,EAAkBH,EAA6C,CACtE,IAAMI,EAA2B,CAAE,KAAM,QAAS,EAClD,OAAIJ,EAAM,UAAY,IAAGI,EAAK,UAAYJ,EAAM,WAC5CA,EAAM,UAAY,GAAKA,EAAM,YAAc,SAAQI,EAAK,UAAYJ,EAAM,WAC1EA,EAAM,UAASI,EAAK,QAAUJ,EAAM,SACjCI,CACT,CAEA,SAASF,EAAiBG,EAA+C,CACvE,IAAMC,EAAU,MAAM,KAAKD,EAAO,OAAO,EACtC,OAAQE,GAAMA,EAAE,QAAU,EAAE,EAC5B,IAAKA,GAAMA,EAAE,KAAK,EAErB,OAAID,EAAQ,SAAW,EACd,CAAE,KAAM,QAAS,EAGnB,CACL,KAAM,SACN,KAAMA,CACR,CACF,CAGO,SAASE,EAAiBC,EAAuBC,EAAwB,CAI9E,OAHe,MAAM,KACnBD,EAAK,iBAAmC,6BAA6B,IAAI,OAAOC,CAAI,CAAC,IAAI,CAC3F,EACc,IAAK,GAAM,EAAE,KAAK,EAAE,OAAQC,GAAMA,IAAM,EAAE,CAC1D,CCxHA,IAAIC,EAAY,EAQT,SAASC,EAAYC,EAAuBC,EAAuC,CACxF,IAAMC,EAAOD,GAAU,MAAQE,EAAcH,CAAI,EAC3CI,EAAcH,GAAU,aAAeI,EAAqBL,CAAI,EAChEM,EAAcC,EAAYP,CAAI,EAEpC,MAAO,CAAE,KAAAE,EAAM,YAAAE,EAAa,YAAAE,CAAY,CAC1C,CAMA,SAASH,EAAcH,EAA+B,CAEpD,IAAMQ,EAAWR,EAAK,QAAQ,WAC9B,GAAIQ,EAAU,OAAOC,EAAaD,CAAQ,EAG1C,IAAME,EAAaC,EAAoBX,CAAI,EAC3C,GAAIU,EAAY,OAAOD,EAAaC,CAAU,EAG9C,IAAME,EAAUC,EAAsBb,CAAI,EAC1C,GAAIY,EAAS,OAAOH,EAAaG,CAAO,EAGxC,GAAIZ,EAAK,GAAI,OAAOS,EAAaT,EAAK,EAAE,EACxC,GAAIA,EAAK,KAAM,OAAOS,EAAaT,EAAK,IAAI,EAG5C,GAAIA,EAAK,OAAQ,CACf,IAAMc,EAAUC,EAAmBf,EAAK,MAAM,EAC9C,GAAIc,EAAS,OAAOL,EAAaK,CAAO,CAC1C,CAGA,MAAO,QAAQ,EAAEE,CAAS,EAC5B,CAEA,SAASP,EAAaQ,EAAqB,CACzC,OAAOA,EACJ,YAAY,EACZ,KAAK,EACL,QAAQ,cAAe,GAAG,EAC1B,QAAQ,WAAY,EAAE,EACtB,MAAM,EAAG,EAAE,GAAK,MACrB,CAEA,SAASN,EAAoBX,EAA+B,CAC1D,IAAMkB,EAAU,CACd,GAAG,MAAM,KAAKlB,EAAK,iBAAoC,2CAA2C,CAAC,EACnG,GAAG,MAAM,KAAKA,EAAK,iBAAmC,sBAAsB,CAAC,CAC/E,EAEA,QAAWmB,KAAOD,EAAS,CACzB,IAAME,EACJD,aAAe,iBACXA,EAAI,MAAM,KAAK,EACfA,EAAI,aAAa,KAAK,GAAK,GACjC,GAAIC,GAAQA,EAAK,OAAS,GAAKA,EAAK,OAAS,GAAI,OAAOA,CAC1D,CACA,MAAO,EACT,CAEA,SAASP,EAAsBb,EAA+B,CAE5D,IAAIqB,EAAuBrB,EAC3B,KAAOqB,GAAM,CAEX,IAAIC,EAAUD,EAAK,uBACnB,KAAOC,GAAS,CACd,GAAI,YAAY,KAAKA,EAAQ,OAAO,EAAG,CACrC,IAAMF,EAAOE,EAAQ,aAAa,KAAK,GAAK,GAC5C,GAAIF,EAAM,OAAOA,CACnB,CACAE,EAAUA,EAAQ,sBACpB,CAGA,GAFAD,EAAOA,EAAK,cAER,CAACA,GAAQA,IAAS,SAAS,KAAM,KACvC,CACA,MAAO,EACT,CAEA,SAASN,EAAmBQ,EAAqB,CAC/C,GAAI,CAEF,IAAMC,EADS,IAAI,IAAID,EAAK,OAAO,SAAS,IAAI,EACxB,SAAS,MAAM,GAAG,EAAE,OAAO,OAAO,EAC1D,OAAOC,EAASA,EAAS,OAAS,CAAC,GAAK,EAC1C,MAAQ,CACN,MAAO,EACT,CACF,CAMA,SAASnB,EAAqBL,EAA+B,CAE3D,IAAMQ,EAAWR,EAAK,QAAQ,kBAC9B,GAAIQ,EAAU,OAAOA,EAAS,KAAK,EAGnC,IAAMiB,EAASzB,EAAK,cAAc,QAAQ,EAC1C,GAAIyB,GAAQ,aAAa,KAAK,EAAG,OAAOA,EAAO,YAAY,KAAK,EAGhE,IAAMC,EAAY1B,EAAK,aAAa,YAAY,EAChD,GAAI0B,GAAW,KAAK,EAAG,OAAOA,EAAU,KAAK,EAG7C,IAAMC,EAAgB3B,EAAK,aAAa,kBAAkB,EAC1D,GAAI2B,EAAe,CACjB,IAAMC,EAAS,SAAS,eAAeD,CAAa,EACpD,GAAIC,GAAQ,aAAa,KAAK,EAAG,OAAOA,EAAO,YAAY,KAAK,CAClE,CAGA,IAAMhB,EAAUC,EAAsBb,CAAI,EACpC6B,EAAY,SAAS,OAAO,KAAK,EACvC,OAAIjB,GAAWiB,EAAkB,GAAGjB,CAAO,WAAMiB,CAAS,GACtDjB,GACAiB,GAEG,aACT,CAMA,SAAStB,EAAYP,EAAmC,CACtD,IAAM8B,EAAiD,CAAC,EAClDC,EAAqB,CAAC,EAGtBC,EAAuB,IAAI,IAE3BC,EAAW,MAAM,KACrBjC,EAAK,iBACH,yBACF,CACF,EAEA,QAAWkC,KAAWD,EAAU,CAE9B,IAAM/B,EAAOgC,EAAQ,KACrB,GAAI,CAAChC,EAAM,SAGX,GACEgC,aAAmB,kBACnBA,EAAQ,OAAS,QACjB,CACA,GAAIF,EAAqB,IAAI9B,CAAI,EAAG,SACpC8B,EAAqB,IAAI9B,CAAI,CAC/B,CAEA,IAAMiC,EAAaC,EAAkBF,CAAO,EAC5C,GAAI,CAACC,EAAY,SAGjBA,EAAW,MAAQE,EAAgBH,CAAO,EAC1C,IAAMI,EAAOC,EAAsBL,CAAO,EACtCI,IAAMH,EAAW,YAAcG,GAIjCJ,aAAmB,kBACnBA,EAAQ,OAAS,UAEjBC,EAAW,KAAOK,EAAiBxC,EAAME,CAAI,GAG/C4B,EAAW5B,CAAI,EAAIiC,EAGfD,EAAQ,UACVH,EAAS,KAAK7B,CAAI,CAEtB,CAEA,MAAO,CAAE,KAAM,SAAU,WAAA4B,EAAY,SAAAC,CAAS,CAChD,CAEA,SAASM,EACPH,EACQ,CAER,GAAI,YAAaA,GAAYA,EAAwB,QAAQ,YAC3D,OAAQA,EAAwB,QAAQ,YAI1C,IAAMO,EAAYC,GAAuBR,CAAO,EAChD,OAAIO,IAGAP,EAAQ,KAAaS,EAAaT,EAAQ,IAAI,EAG9CA,EAAQ,GAAWS,EAAaT,EAAQ,EAAE,EAEvC,GACT,CAEA,SAASK,EACPL,EACQ,CAER,IAAMU,EAAKV,EACX,GAAIU,EAAG,QAAQ,kBAAsB,OAAOA,EAAG,QAAQ,kBAGvD,IAAMC,EAAWX,EAAQ,aAAa,kBAAkB,EACxD,GAAIW,EAAU,OAAOA,EAErB,IAAMlB,EAAgBO,EAAQ,aAAa,kBAAkB,EAC7D,GAAIP,EAAe,CACjB,IAAMC,EAAS,SAAS,eAAeD,CAAa,EACpD,GAAIC,GAAQ,aAAa,KAAK,EAAG,OAAOA,EAAO,YAAY,KAAK,CAClE,CAGA,GAAIM,aAAmB,kBAAoBA,aAAmB,oBAAqB,CACjF,IAAMY,EAAKZ,EAAQ,aAAa,KAAK,EACrC,GAAIY,GAAMA,EAAG,OAAS,EAAG,OAAOA,CAClC,CAGA,MAAO,EACT,CAEA,SAASJ,GACPR,EACQ,CAER,GAAIA,EAAQ,GAAI,CACd,IAAMa,EAAQ,SAAS,cAAgC,cAAc,IAAI,OAAOb,EAAQ,EAAE,CAAC,IAAI,EAC/F,GAAIa,EAAO,CACT,IAAM3B,EAAO4B,EAAuBD,CAAK,EACzC,GAAI3B,EAAM,OAAOA,CACnB,CACF,CAGA,IAAM6B,EAASf,EAAQ,QAAQ,OAAO,EACtC,GAAIe,EAAQ,CACV,IAAM7B,EAAO4B,EAAuBC,CAAM,EAC1C,GAAI7B,EAAM,OAAOA,CACnB,CAEA,MAAO,EACT,CAEA,SAAS4B,EAAuBD,EAAiC,CAE/D,IAAMG,EAAQH,EAAM,UAAU,EAAI,EAClC,OAAAG,EAAM,iBAAiB,iCAAiC,EAAE,QAASN,GAAOA,EAAG,OAAO,CAAC,EAC9EM,EAAM,aAAa,KAAK,GAAK,EACtC,CAEA,SAASP,EAAa1B,EAAqB,CACzC,OAAOA,EACJ,QAAQ,QAAS,GAAG,EACpB,QAAQ,kBAAmB,OAAO,EAClC,KAAK,EACL,QAAQ,QAAUkC,GAAMA,EAAE,YAAY,CAAC,CAC5C,CC7RAC,IC6BA,IAAMC,EAAoB,IAAI,QAavB,SAASC,EACdC,EACAC,EAC6D,CAE7D,OAAAC,GAAwBF,CAAI,EAErB,MAAOG,IACZC,GAAeJ,EAAMG,CAAM,EAEpB,IAAI,QAAuB,CAACE,EAASC,IAAW,CACrDR,EAAkB,IAAIE,EAAM,CAAE,QAAAK,EAAS,OAAAC,CAAO,CAAC,GAE3CL,EAAO,YAAcD,EAAK,QAAQ,mBAAwB,SAE5DA,EAAK,cAAc,CAIvB,CAAC,EAEL,CAEA,SAASE,GAAwBF,EAA6B,CAEvDA,EAA4C,sBAChDA,EAA4C,oBAAyB,GAEtEA,EAAK,iBAAiB,SAAWO,GAAmB,CAClD,IAAMC,EAAUV,EAAkB,IAAIE,CAAI,EAC1C,GAAI,CAACQ,EAAS,OAGd,GAAM,CAAE,QAAAH,CAAQ,EAAIG,EACpBV,EAAkB,OAAOE,CAAI,EAE7B,IAAMS,EAAWC,GAAkBV,CAAI,EAEvC,GAAIO,EAAE,cAAgB,OAAOA,EAAE,aAAgB,WAE7CA,EAAE,eAAe,EACjBA,EAAE,YACA,QAAQ,QAAQ,CACd,QAAS,GACT,KAAME,CACR,CAAC,CACH,EACAJ,EAAQ,CAAE,QAAS,GAAM,KAAMI,CAAS,CAAC,MACpC,CAEL,IAAME,EAAYC,GAAkBZ,CAAI,EACxCK,EAAQ,CAAE,QAAS,GAAM,KAAMI,EAAU,IAAKE,CAAU,CAAC,CAC3D,CACF,CAAC,EACH,CAMA,SAASP,GAAeJ,EAAuBG,EAAuC,CACpF,OAAW,CAACU,EAAMC,CAAK,IAAK,OAAO,QAAQX,CAAM,EAAG,CAClD,IAAMY,EAAc,IAAI,OAAOF,CAAI,EAG7BG,EAAQhB,EAAK,cACjB,UAAUe,CAAW,IACvB,EAEKC,IAEDA,aAAiB,iBACnBC,GAAUD,EAAOhB,EAAMa,EAAMC,CAAK,EACzBE,aAAiB,qBAC1BA,EAAM,MAAQ,OAAOF,GAAS,EAAE,EAChCE,EAAM,cAAc,IAAI,MAAM,QAAS,CAAE,QAAS,EAAK,CAAC,CAAC,EACzDA,EAAM,cAAc,IAAI,MAAM,SAAU,CAAE,QAAS,EAAK,CAAC,CAAC,GACjDA,aAAiB,oBAC1BA,EAAM,MAAQ,OAAOF,GAAS,EAAE,EAChCE,EAAM,cAAc,IAAI,MAAM,SAAU,CAAE,QAAS,EAAK,CAAC,CAAC,GAE9D,CACF,CAEA,SAASC,GACPD,EACAhB,EACAa,EACAC,EACM,CACN,IAAMI,EAAOF,EAAM,KAAK,YAAY,EAEpC,GAAIE,IAAS,WAAY,CACvBF,EAAM,QAAU,EAAQF,EACxBE,EAAM,cAAc,IAAI,MAAM,SAAU,CAAE,QAAS,EAAK,CAAC,CAAC,EAC1D,MACF,CAEA,GAAIE,IAAS,QAAS,CACpB,IAAMH,EAAc,IAAI,OAAOF,CAAI,EAC7BM,EAASnB,EAAK,iBAClB,6BAA6Be,CAAW,IAC1C,EACA,QAAWK,KAASD,EAClB,GAAIC,EAAM,QAAU,OAAON,CAAK,EAAG,CACjCM,EAAM,QAAU,GAChBA,EAAM,cAAc,IAAI,MAAM,SAAU,CAAE,QAAS,EAAK,CAAC,CAAC,EAC1D,KACF,CAEF,MACF,CAEAJ,EAAM,MAAQ,OAAOF,GAAS,EAAE,EAChCE,EAAM,cAAc,IAAI,MAAM,QAAS,CAAE,QAAS,EAAK,CAAC,CAAC,EACzDA,EAAM,cAAc,IAAI,MAAM,SAAU,CAAE,QAAS,EAAK,CAAC,CAAC,CAC5D,CAMA,SAASN,GAAkBV,EAAgD,CACzE,IAAMqB,EAAkC,CAAC,EACnCC,EAAO,IAAI,SAAStB,CAAI,EAE9B,OAAW,CAACuB,EAAKC,CAAG,IAAKF,EAAK,QAAQ,EACpC,GAAID,EAAOE,CAAG,IAAM,OAAW,CAE7B,IAAME,EAAWJ,EAAOE,CAAG,EACvB,MAAM,QAAQE,CAAQ,EACxBA,EAAS,KAAKD,CAAG,EAEjBH,EAAOE,CAAG,EAAI,CAACE,EAAUD,CAAG,CAEhC,MACEH,EAAOE,CAAG,EAAIC,EAIlB,OAAOH,CACT,CAEA,SAAST,GAAkBZ,EAA+B,CACxD,GAAIA,EAAK,OACP,GAAI,CACF,OAAO,IAAI,IAAIA,EAAK,OAAQ,OAAO,SAAS,IAAI,EAAE,IACpD,MAAQ,CAER,CAEF,OAAO,OAAO,SAAS,IACzB,CC9LA,eAAsB0B,EACpBC,EACAC,EACuB,CACvB,GAAI,CACF,IAAMC,EAAW,MAAMC,GAAQH,EAAUC,CAAQ,EACjD,MAAO,CAAE,GAAGD,EAAU,YAAaE,CAAS,CAC9C,OAASE,EAAK,CAEZ,eAAQ,KAAK,gEAAiEA,CAAG,EAC1EJ,CACT,CACF,CAEA,eAAeG,GAAQH,EAAwBK,EAAyC,CACtF,IAAMC,EAASC,GAAYP,CAAQ,EAEnC,OAAIK,EAAO,WAAa,SACfG,GAAWF,EAAQD,CAAM,EAEzBI,GAAWH,EAAQD,CAAM,CAEpC,CAEA,SAASE,GAAYP,EAAgC,CACnD,IAAMU,EAAS,OAAO,QAAQV,EAAS,YAAY,UAAU,EAC1D,IAAI,CAAC,CAACW,EAAMC,CAAI,IAAM,KAAKA,EAAK,OAASD,CAAI,KAAKC,EAAK,IAAI,MAAMA,EAAK,aAAe,EAAE,EAAE,EACzF,KAAK;AAAA,CAAI,EAEZ,MAAO;AAAA;AAAA,QAEDZ,EAAS,IAAI;AAAA,uBACEA,EAAS,WAAW;AAAA;AAAA,EAEzCU,CAAM;AAAA;AAAA,kLAGR,CAEA,eAAeF,GAAWF,EAAgBD,EAAyC,CACjF,IAAMQ,EAAQR,EAAO,OAAS,4BAExBS,EAAW,MAAM,MAAM,wCAAyC,CACpE,OAAQ,OACR,QAAS,CACP,YAAaT,EAAO,OACpB,oBAAqB,aACrB,eAAgB,kBAClB,EACA,KAAM,KAAK,UAAU,CACnB,MAAAQ,EACA,WAAY,IACZ,SAAU,CAAC,CAAE,KAAM,OAAQ,QAASP,CAAO,CAAC,CAC9C,CAAC,CACH,CAAC,EAED,GAAI,CAACQ,EAAS,GACZ,MAAM,IAAI,MAAM,qBAAqBA,EAAS,MAAM,EAAE,EAOxD,OAJa,MAAMA,EAAS,KAAK,GAIrB,QACT,OAAQC,GAAUA,EAAM,OAAS,MAAM,EACvC,IAAKA,GAAUA,EAAM,IAAI,EACzB,KAAK,EAAE,EACP,KAAK,CACV,CAEA,eAAeN,GAAWH,EAAgBD,EAAyC,CAEjF,IAAMW,EAAM,2DADEX,EAAO,OAAS,kBAC8C,wBAAwBA,EAAO,MAAM,GAE3GS,EAAW,MAAM,MAAME,EAAK,CAChC,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAmB,EAC9C,KAAM,KAAK,UAAU,CACnB,SAAU,CAAC,CAAE,MAAO,CAAC,CAAE,KAAMV,CAAO,CAAC,CAAE,CAAC,EACxC,iBAAkB,CAAE,gBAAiB,IAAK,YAAa,EAAI,CAC7D,CAAC,CACH,CAAC,EAED,GAAI,CAACQ,EAAS,GACZ,MAAM,IAAI,MAAM,qBAAqBA,EAAS,MAAM,EAAE,EASxD,OANa,MAAMA,EAAS,KAAK,GAMrB,WAAW,CAAC,GAAG,QAAQ,MAAM,IAAKG,GAAMA,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,KAAK,GAAK,EACjF,CFtFA,SAASC,EAAKC,EAA+CC,EAAuBC,EAAwB,CAC1G,OAAO,cACL,IAAI,YAAYF,EAAM,CAAE,OAAQ,CAAE,KAAAC,EAAM,SAAAC,CAAS,CAAE,CAAC,CACtD,CACF,CAOA,SAASC,GAAWF,EAAuBG,EAAiC,CAI1E,GAFIH,EAAK,aAAa,UAAU,GAE5BA,EAAK,QAAQ,WAAgB,OAAW,MAAO,GAEnD,QAAWI,KAAYD,EAAO,QAC5B,GAAI,CACF,GAAIH,EAAK,QAAQI,CAAQ,EAAG,MAAO,EACrC,MAAQ,CAER,CAEF,MAAO,EACT,CAEA,eAAeC,EAAaL,EAAuBG,EAAuC,CACxF,GAAID,GAAWF,EAAMG,CAAM,EAAG,OAG9B,IAAIG,EACJ,OAAW,CAACF,EAAUG,CAAG,IAAK,OAAO,QAAQJ,EAAO,SAAS,EAC3D,GAAI,CACF,GAAIH,EAAK,QAAQI,CAAQ,EAAG,CAC1BE,EAAWC,EACX,KACF,CACF,MAAQ,CAER,CAGF,IAAIC,EAAWC,EAAYT,EAAMM,CAAQ,EACrCH,EAAO,UACLA,EAAO,OAAO,QAAQ,MAAM,4BAA4BK,EAAS,IAAI,QAAG,EAC5EA,EAAW,MAAME,EAAeF,EAAUL,EAAO,OAAO,GAE1D,IAAMQ,EAAUC,EAAoBZ,EAAMG,CAAM,EAEhD,MAAMU,EAAiBb,EAAMQ,EAAUG,CAAO,EAE1CR,EAAO,OACT,QAAQ,MAAM,6BAA6BK,EAAS,IAAI,GAAIA,CAAQ,EAGtEV,EAAK,kBAAmBE,EAAMQ,EAAS,IAAI,CAC7C,CAEA,eAAeM,GAAed,EAAuBG,EAAuC,CAC1F,GAAM,CAAE,sBAAAY,CAAsB,EAAI,KAAM,qCAClCC,EAAOD,EAAsBf,CAAI,EAClCgB,IAEL,MAAMC,EAAmBjB,CAAI,EAEzBG,EAAO,OACT,QAAQ,MAAM,+BAA+Ba,CAAI,EAAE,EAGrDlB,EAAK,oBAAqBE,EAAMgB,CAAI,EACtC,CAMA,IAAIE,EAAoC,KAExC,SAASC,GAAchB,EAA8B,CAC/Ce,IAEJA,EAAW,IAAI,iBAAkBE,GAAc,CAC7C,QAAWC,KAAYD,EAAW,CAChC,QAAWE,KAAQD,EAAS,WAAY,CACtC,GAAI,EAAEC,aAAgB,SAAU,SAEhC,IAAMC,EAAQD,aAAgB,gBAC1B,CAACA,CAAI,EACL,MAAM,KAAKA,EAAK,iBAAkC,MAAM,CAAC,EAE7D,QAAWtB,KAAQuB,EACZlB,EAAaL,EAAMG,CAAM,CAElC,CAEA,QAAWmB,KAAQD,EAAS,aAAc,CACxC,GAAI,EAAEC,aAAgB,SAAU,SAEhC,IAAMC,EAAQD,aAAgB,gBAC1B,CAACA,CAAI,EACL,MAAM,KAAKA,EAAK,iBAAkC,MAAM,CAAC,EAE7D,QAAWtB,KAAQuB,EACZT,GAAed,EAAMG,CAAM,CAEpC,CACF,CACF,CAAC,EAEDe,EAAS,QAAQ,SAAS,KAAM,CAAE,UAAW,GAAM,QAAS,EAAK,CAAC,EACpE,CAMA,SAASM,GAAsBrB,EAA8B,CAE3D,OAAO,iBAAiB,aAAc,IAAMsB,EAAUtB,CAAM,CAAC,EAG7D,IAAMuB,EAAW,CACf,UAAW,QAAQ,UAAU,KAAK,OAAO,EACzC,aAAc,QAAQ,aAAa,KAAK,OAAO,CACjD,EAEA,QAAQ,UAAY,YAAaC,EAAM,CACrCD,EAAS,UAAU,GAAGC,CAAI,EAC1BF,EAAUtB,CAAM,CAClB,EAEA,QAAQ,aAAe,YAAawB,EAAM,CACxCD,EAAS,aAAa,GAAGC,CAAI,EAC7BF,EAAUtB,CAAM,CAClB,EAEA,OAAO,iBAAiB,WAAY,IAAMsB,EAAUtB,CAAM,CAAC,CAC7D,CAMA,eAAesB,EAAUtB,EAAuC,CAC9D,IAAMoB,EAAQ,MAAM,KAAK,SAAS,iBAAkC,MAAM,CAAC,EAC3E,MAAM,QAAQ,IAAIA,EAAM,IAAKvB,GAASK,EAAaL,EAAMG,CAAM,CAAC,CAAC,CACnE,CAMA,eAAsByB,EAAezB,EAAuC,CACtE,SAAS,aAAe,WAC1B,MAAM,IAAI,QAAe0B,GACvB,SAAS,iBAAiB,mBAAoB,IAAMA,EAAQ,EAAG,CAAE,KAAM,EAAK,CAAC,CAC/E,EAGF,MAAMJ,EAAUtB,CAAM,EACtBgB,GAAchB,CAAM,EACpBqB,GAAsBrB,CAAM,CAC9B,CAEO,SAAS2B,GAAsB,CACpCZ,GAAU,WAAW,EACrBA,EAAW,IACb,CJ9KAa,IAqBA,eAAsBC,EAAWC,EAAsD,CACrF,IAAMC,EAAWC,EAAcF,CAAM,EAErC,OAAIC,EAAS,OACX,QAAQ,MAAM,6BAA8B,CAC1C,gBAAiBE,EAAkB,EACnC,OAAQF,CACV,CAAC,EAGH,MAAMG,EAAeH,CAAQ,EAEtB,CACL,QAAS,SAAY,CACnBI,EAAc,EACd,MAAMC,EAAc,CACtB,EACA,SAAUC,EACV,YAAaJ,EAAkB,CACjC,CACF,CAWE,OAAO,OAAW,KAClB,CAAE,OAA8C,2BAE3CJ,EAAW",
  "names": ["registry_exports", "__export", "getAllRegisteredTools", "getRegisteredToolName", "isWebMCPSupported", "registerFormTool", "unregisterAll", "unregisterFormTool", "form", "metadata", "execute", "registeredTools", "name", "entries", "init_registry", "__esmMin", "src_exports", "__export", "autoWebMCP", "resolveConfig", "userConfig", "inputTypeToSchema", "input", "mapInputElement", "mapSelectElement", "buildStringSchema", "prop", "select", "options", "o", "collectRadioEnum", "form", "name", "v", "formIndex", "analyzeForm", "form", "override", "name", "inferToolName", "description", "inferToolDescription", "inputSchema", "buildSchema", "explicit", "sanitizeName", "submitText", "getSubmitButtonText", "heading", "getNearestHeadingText", "segment", "getLastPathSegment", "formIndex", "raw", "buttons", "btn", "text", "node", "sibling", "url", "segments", "legend", "ariaLabel", "describedById", "descEl", "pageTitle", "properties", "required", "processedRadioGroups", "controls", "control", "schemaProp", "inputTypeToSchema", "inferFieldTitle", "desc", "inferFieldDescription", "collectRadioEnum", "labelText", "getAssociatedLabelText", "humanizeName", "el", "ariaDesc", "ph", "label", "labelTextWithoutNested", "parent", "clone", "c", "init_registry", "pendingExecutions", "buildExecuteHandler", "form", "config", "attachSubmitInterceptor", "params", "fillFormFields", "resolve", "reject", "e", "pending", "formData", "serializeFormData", "targetUrl", "resolveFormAction", "name", "value", "escapedName", "input", "fillInput", "type", "radios", "radio", "result", "data", "key", "val", "existing", "enrichMetadata", "metadata", "enhancer", "enriched", "callLLM", "err", "config", "prompt", "buildPrompt", "callClaude", "callGemini", "fields", "name", "prop", "model", "response", "block", "url", "p", "emit", "type", "form", "toolName", "isExcluded", "config", "selector", "registerForm", "override", "ovr", "metadata", "analyzeForm", "enrichMetadata", "execute", "buildExecuteHandler", "registerFormTool", "unregisterForm", "getRegisteredToolName", "name", "unregisterFormTool", "observer", "startObserver", "mutations", "mutation", "node", "forms", "listenForRouteChanges", "scanForms", "original", "args", "startDiscovery", "resolve", "stopDiscovery", "init_registry", "autoWebMCP", "config", "resolved", "resolveConfig", "isWebMCPSupported", "startDiscovery", "stopDiscovery", "unregisterAll", "getAllRegisteredTools"]
}
